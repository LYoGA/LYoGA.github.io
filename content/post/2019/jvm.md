---
title: "Jvm"
date: 2019-06-07T16:12:03+08:00
lastmod: 2019-06-07T16:12:03+08:00
draft: true
keywords:
-
description: ""
tags:
-
categories:
-
author: "lyoga"
---

<!--more-->

# **JVM内存结构**#

## **JVM整体由4部分组成**##

1. 类加载子系统
2. 执行引擎
3. 运行时数据区
4. 内存回收

## **运行时数据区：**##
1. 程序计数器：线程所执行的字节码的行号指示器
2. JAVA虚拟机栈：每个方法被执行的时候都会同时创建一个栈帧用于存放局部变量表（编译时确定大小）、操作栈、动态链接、方法出口等信息
3. 本地方法栈：针对native方法
4. 堆：几乎所有的对象实例都在堆分配（栈上分配&TLAB）
  - 栈上分配：针对那些作用域不会逃逸出方法的对象，在分配内存时不在将对象分配在堆内存中，而是将对象属性打散后分配在栈上，这样随着方法的调用结束，栈空间的回收就会随着将栈上分配的打散后的对象回收掉，不再给gc增加额外的无用负担，从而提升应用程序整体的性能（开启逃逸分析&标量替换）
  - TLAB(Thread Local Allocation Buffer)：线程本地分配缓存，是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，均摊对GC堆（eden区）里共享的分配指针做更新而带来的同步开销
5. 方法区：用于存储已被虚拟机加载的类信息（Class）、常量、静态变量、即时编译器编译后的代码等数据
  - Class文件常量池：字面量&符号引用
  - 运行时常量池：存储Java class文件常量池中的符号信息；运行时常量池中保存着一些class文件中描述的符号引用，同时在类加载的“解析阶段”还会将这些符号引用所翻译出来的直接引用(直接指向实例对象的指针)存储在运行时常量池中
  - 字符串常量池：字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。
6. 元空间：元空间并不在虚拟机中，而是使用本地内存，本地内存消耗完也会报OOM，类及相关的元数据的生命周期与类加载器的一致
  - 本地内存分配
  - 使用块分配器，线性分配，以类加载器为单位，块的大小取决于类加载器的类型

## **JDK7、8区别**##
- JDK7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap，比如符号引用(Symbols)转移到了native heap，字符串常量池(interned strings)转移到了java heap
- JDK8中，永久代已经完全被元空间取代
  - PermGen内存经常溢出（OOM）&移除PermGen可以促进HotSpot JVM与JRockit VM的融合，因为JRockit没有永久代


# **内存回收** #
## **对象存活判定**##
- 引用计数：循环引用，造成内存泄漏
- 可达性算法分析：GC Roots作为起点，向下搜索，判断哪些对象是没有任何引用链，是不可达的
  - GC Roots对象：
      - JAVA栈（栈帧中的局部变量表，Local Variable Table）中引用的对象
      - 本地方法栈中JNI（即一般说的Native方法）引用的对象
      - 方法区中类静态变量引用的对象
      - 方法区中常量引用的对象
  - 选取依据：
      - 确定是存活的对象集
      - 全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的局部变量表）
      - JAVA栈、方法区和本地方法栈不被GC所管理


## **两次标记与finalize()**##
- 真正宣告一个对象死亡，有可能经历两次标记过程
- 对象在经历可达性分析之后，无任何引用链，那它将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize方法
- 对象无覆盖finalize方法或者已经调用过了，就直接回收
- 如果有必要执行，将对象放到一个叫做F-Queue的队列中，之后由虚拟机自动建立的低优先级的Finalize线程执行，不会承诺会等待运行结束，不可控的
- finalize方法是对象最后一次逃脱机会，稍后GC将对F-Queue队列进行小规模二次标记，看是否有引用链
- 不建议使用，建议忘掉这个方法

## **回收方法区**##
- 该类所有实例已被回收
- 加载该类的类加载器也被回收
- 类对应的class对象，无任何地方被引用，主要无法通过反射获得
- 元空间：当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收

## **垃圾回收算法**##
- 标记-清除：简单直接，但会造成内存碎片
- 复制：内存对半分，简单，不会产生内存碎片，但会浪费部分内存空间
- 标记-整理：压缩空间碎片，不会产生内存碎片
- 分代收集
  - 新生代：Minor GC，复制算法，eden：from survivor：to survivor = 8：1：1，浪费10%新生代容量，比例可调
      - Minor GC将eden与from survivor中还存活的对象复制到to survivor，然后清理eden与from survivor
      - 交换from survivor与to survivor标签

## **HotSpot算法实现**##
1. 枚举GC Roots
2. GC停顿：可达性分析工作必须在一个能确保一致性的快照中进行（STW - Stop The World）
3. 准确式GC与OopMap
  - 准确式内存管理，虚拟机可以知道内存中某个位置的数据具体是什么类型
  - OopMap数据结构存储这些信息，类加载完成，HotSpot就把对象什么偏移量上是什么类型算出来，JIT编译过程中，也会在特定位置记录下栈和寄存器中哪些位置是引用
4. 安全点：进行GC时程序停顿的位置
5. 安全区域：安全区域是指在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的


## **内存分配策略**##
**对象的内存分配：栈上分配 -> TLAB分配 -> 堆上分配**

1. 对象优先在Eden区分配
2. 大对象直接进入老年代
3. 长期存活对象将进入老年代，默认15岁，经过15次移动
4. 动态年龄对象判定：如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄
5. 空间分配担保：进行Minor GC之前，会检查老年代可用连续空间是否大于新生代所有对象总和，如果不成立就看HandlePromotionFailure设置值是否允许担保失败
  - 如果允许，检查当前老年代可用连续空间是否大于历次晋升老年代对象的平均值，如果大于，将尝试进行一次Minor GC，如果小于，则Full GC

## **Full GC触发条件**##
1. 调用System.gc()
2. 老年代空间不足
3. 空间分配担保失败
4. 1.7以及以前永久代空间不足
5. CMS GC过程中同时有对象放入老年代，而老年代空间不足（有可能是浮动垃圾过多导致），便会报Concurrent Mode Failure错误，并触发Full GC

# **垃圾回收器**#
